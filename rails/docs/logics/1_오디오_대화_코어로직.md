# 1. 오디오 대화 코어 로직 스펙 (v3 - 단순화)

## 변경 이력
- **v1**: STI 구조
- **v2**: Polymorphic 구조 + chat_participants 테이블
- **v3**: chat_participants 제거, 1:1 구조 단순화, Echo 중심 라우팅

---

## 1. 개요 및 설계 의도

이 문서는 보이스 SNS의 핵심 기능인 '오디오 대화'의 데이터 모델과 핵심 로직을 최종적으로 정의합니다. 

### 설계 목표 및 의도

- **명확한 책임 분리 (Polymorphic 채택 이유):** '피드에 공개되는 목소리(`Echo`)'와 '대화방의 비공개 메시지(`Message`)'는 본질적으로 다른 맥락과 생명주기를 가집니다. 다형성 구조는 오디오 파일 자체를 관리하는 `Recording` 모델과, 각 오디오의 맥락을 정의하는 `Echo`, `Message` 모델을 명확히 분리합니다.

- **Echo 중심 라우팅:** 대화방은 항상 특정 Echo를 기반으로 시작되며, `/echos/:id` 경로를 통해 접근합니다. 별도의 `/chat_rooms/:id` 경로는 사용하지 않으며, Echo ID를 통해 서버에서 ChatRoom을 식별합니다.

- **1:1 구조 단순화:** 모든 대화는 Echo 작성자와 답장자 간의 1:1 구조입니다. chat_participants 중간 테이블 없이 chat_rooms에 직접 두 참여자 정보를 저장하여 구조를 단순화합니다.

- **독립적인 대화방:** 대화가 시작될 때, 원본 `Echo`의 오디오 파일을 **복사**하여 대화방의 첫 `Message`로 만듭니다. 이로써 `ChatRoom`은 시작점이었던 `Echo`가 피드에서 사라지더라도 아무런 영향을 받지 않습니다.

---

## 2. 데이터 모델 구조

### `echos` 테이블
- `id`: Primary Key
- `user_id`: 메아리를 남긴 사용자 (FK)
- `created_at`, `updated_at`

### `chat_rooms` 테이블
- `id`: Primary Key
- `echo_id`: 어떤 `Echo`로부터 시작되었는지 (FK to `echos`)
- `initiator_user_id`: Echo 작성자 (FK to `users`)
- `responder_user_id`: 답장한 사람 (FK to `users`)
- `initiator_left_at`: Echo 작성자가 대화를 떠난 시간 (nullable)
- `responder_left_at`: 답장자가 대화를 떠난 시간 (nullable)
- `last_message_at`: 마지막 메시지 시간 (비활성 처리용)
- `created_at`, `updated_at`

### `messages` 테이블
- `id`: Primary Key
- `user_id`: 메시지를 보낸 사용자 (FK)
- `chat_room_id`: 메시지가 속한 대화방 (FK)
- `created_at`, `updated_at`

### `recordings` 테이블
- `id`: Primary Key
- `user_id`: 오디오를 녹음한 원본 사용자 (FK)
- `audio_file_data`: 오디오 파일 (Active Storage)
- `belongable_type`: (String, "Echo", "Message")
- `belongable_id`: (Integer, `echos.id` or `messages.id`)
- `created_at`, `updated_at`

### 모델 관계
- `Echo`: `has_one :recording, as: :belongable, dependent: :destroy`, `belongs_to :user`, `has_many :chat_rooms`
- `Message`: `has_one :recording, as: :belongable, dependent: :destroy`, `belongs_to :user`, `belongs_to :chat_room`
- `Recording`: `belongs_to :belongable, polymorphic: true`, `belongs_to :user`
- `ChatRoom`: `belongs_to :echo`, `belongs_to :initiator, class_name: 'User'`, `belongs_to :responder, class_name: 'User'`, `has_many :messages`
- `User`: `has_many :echos`, `has_many :messages`, `has_many :chat_rooms_as_initiator`, `has_many :chat_rooms_as_responder`

---

## 3. 현재 구현 상황

### ✅ Phase 1 완료
- Echo 모델 및 Polymorphic Recording 구조 구축
- 피드(`/feed`)에서 Echo 목록 표시
- Echo 생성 기능 (네이티브 앱 오디오 녹음 지원)
- Pull-to-refresh, Infinite scroll
- Echo와 Recording의 1:1 관계 설정

### 🚧 Phase 2 진행 중 (현재)
- ChatRoom, Message 모델 생성
- Echo 상세 화면 (`/echos/:id`) 구현
- 답장을 통한 대화방 생성 로직
- 턴제 메시지 전송 제약
- 대화방 목록 (`/messages`)

### 📅 Phase 3 (예정)
- Reactions 기능

### 📅 Phase 4 (예정)
- 신고/차단 기능

### 📅 Phase 5 (예정)
- 자동 휘발 시스템 (Solid Queue)

---

## 4. 핵심 로직 흐름 (Sequence)

### 가. 피드에서 Echo 클릭 (답장 시작)

**사용자 플로우:**
1. 사용자 B가 피드에서 사용자 A의 Echo 카드 오른쪽 클릭
2. `/echos/:echo_id`로 이동 (Turbo 기본 네비게이션)

**Echo 카드 구조:**
- 왼쪽 영역: 오디오 플레이 버튼
- 오른쪽 영역: Echo 상세 화면으로 이동 (남이 올린 Echo만)
- 내가 올린 Echo: 오른쪽 영역 클릭 불가 (TODO: 복수 대화방 목록 표시)

**Echo 상세 화면 로직 (`EchosController#show`):**
```ruby
def show
  @echo = Echo.find(params[:id])
  
  # Case 1: 내가 올린 Echo인 경우
  if @echo.user == current_user
    # TODO: 복수 대화방 UI 구현
    # 현재는 해당 Echo로부터 생성된 모든 ChatRoom 목록 표시
    @chat_rooms = @echo.chat_rooms.order(last_message_at: :desc)
    @is_my_echo = true
    return
  end
  
  # Case 2: 남이 올린 Echo인 경우
  @chat_room = current_user.chat_rooms.find_by(echo_id: @echo.id)
  @messages = @chat_room ? @chat_room.messages.order(:created_at) : []
end
```

**화면 구성:**
- Echo 오디오 플레이어 (상단 고정)
- 기존 Message 목록 (있는 경우)
- 답장 녹음 UI (하단 footer)

### 나. 대화 시작 (첫 답장)

**트리거:** 사용자 B가 `/echos/:echo_id`에서 답장을 녹음하고 전송

**프로세스 (MessagesController#create - 단일 DB 트랜잭션):**
```ruby
def create
  @echo = Echo.find(params[:echo_id])
  
  # ChatRoom이 없으면 생성
  @chat_room = current_user.chat_rooms.find_by(echo_id: @echo.id)
  
  if @chat_room.nil?
    ActiveRecord::Base.transaction do
      # ChatRoom 생성
      @chat_room = ChatRoom.create!(
        echo: @echo,
        initiator: @echo.user,
        responder: current_user,
        last_message_at: Time.current
      )
      
      # 첫 메시지: Echo 오디오 복사
      first_message = @chat_room.messages.create!(user: @echo.user)
      first_recording = Recording.create!(user: @echo.user, belongable: first_message)
      first_recording.audio_file.attach(@echo.recording.audio_file.blob)
    end
  end
  
  # 두번째 메시지: 답장 생성
  @message = @chat_room.messages.build(user: current_user)
  @recording = Recording.create!(user: current_user, belongable: @message)
  # audio_data 첨부...
end
```

**결과:**
- Turbo Stream으로 Message append (페이지 이동 없음)
- `/echos/:echo_id`에 그대로 머무름

### 다. 대화 진행 (턴제)

**제약 조건:**
```ruby
def create
  last_message = @chat_room.messages.order(:created_at).last
  
  if last_message && last_message.user_id == current_user.id
    # 에러: 상대방의 답장을 기다려야 함
    return render_error("상대방의 답장을 기다려주세요")
  end
  
  # Message 생성...
end
```

### 라. 내가 올린 Echo의 복수 대화방

**Echo 작성자 A의 Echo에 B, C, D가 각각 답장:**
- ChatRoom 1: Echo(A) ↔ B
- ChatRoom 2: Echo(A) ↔ C
- ChatRoom 3: Echo(A) ↔ D

**A가 `/echos/:id`에 접근 시:**
- 해당 Echo로부터 생성된 모든 ChatRoom 목록 표시
- 각 ChatRoom 항목에 responder 정보 및 마지막 메시지 시간 표시
- TODO: 각 ChatRoom 클릭 시 Message 목록 표시 (Turbo Frame 사용)

### 마. 대화방 목록 (`/messages`)

**표시 내용:**
```ruby
def index
  # 남이 올린 Echo에 내가 참여한 대화방만
  @chat_rooms = current_user.chat_rooms
                             .joins(:echo)
                             .where.not(echos: { user_id: current_user.id })
                             .order(last_message_at: :desc)
end
```

각 대화방 항목 클릭 → `/echos/:echo_id`로 이동

**내가 올린 Echo의 대화방:**
- 현재는 목록에서 제외
- TODO: 내가 올린 Echo의 대화방도 별도로 표시

### 바. 대화 종료

**3일 비활성:**
- 백그라운드 잡이 `chat_rooms`의 `last_message_at`을 기준으로 3일 이상 지난 대화를 주기적으로 정리 (Phase 5)

**방 나가기:**
- `initiator_left_at` 또는 `responder_left_at` 업데이트
- 상대방에게는 "상대방이 대화를 떠났습니다" 표시
- 두 사람 모두 떠났으면 ChatRoom 삭제 가능

---

## 5. Footer 녹음 UI Context

**Context별 동작:**
- `/feed`: Echo 생성 (`submit_url: echos_path`)
- `/echos/:id`: Message 생성 (`submit_url: echo_messages_path(@echo)`)
- `/messages`: 숨김 or 비활성
- `/settings`: 숨김 or 비활성

**구현:**
```erb
<!-- app/views/shared/_footer.html.erb -->
<%= form_with(url: submit_url, ...) do |form| %>
  <!-- 녹음 UI -->
<% end %>
```

---

## 6. 신고 및 차단

- 별도 문서에서 정의될 모델을 통해 처리 (Phase 4)
- 차단 시 관련 ChatRoom의 left_at 업데이트하여 모든 상호작용 중단

---

## 7. 향후 고려사항

- **푸시 알림:** 답장 도착 시 알림 (Phase 2에서 로직 준비, 실제 푸시는 나중에)
- **읽음 표시:** 필요 시 추가 가능
- **자동 휘발:** Solid Queue를 통한 스케줄링 (Phase 5)
- **Reactions:** 비공개 반응 시스템 (Phase 3)
