# 1. 오디오 대화 코어 로직 스펙 (v2 - Polymorphic)

## 1. 개요 및 설계 의도

이 문서는 보이스 SNS의 핵심 기능인 '오디오 대화'의 데이터 모델과 핵심 로직을 최종적으로 정의합니다. 이 설계는 v1의 STI 구조 대신, 장기적인 확장성과 명확한 책임 분리를 위해 **다형성(Polymorphic) 연관 관계**를 채택합니다.

### 설계 목표 및 의도

- **명확한 책임 분리 (Polymorphic 채택 이유):** '피드에 공개되는 목소리(`Echo`)'와 '대화방의 비공개 메시지(`Message`)'는 본질적으로 다른 맥락과 생명주기를 가집니다. 다형성 구조는 오디오 파일 자체를 관리하는 `Recording` 모델과, 각 오디오의 맥락을 정의하는 `Echo`, `Message` 모델을 명확히 분리합니다. 이를 통해 각 모델은 자신의 책임에만 집중할 수 있어 코드의 유지보수성과 가독성이 크게 향상됩니다.
- **미래 확장성 확보:** 이 구조는 미래에 완전히 새로운 맥락의 오디오(예: 프로필 음성)가 추가되더라도, 기존 코드를 수정할 필요 없이 새로운 모델과 테이블만 추가하면 되므로 매우 유연합니다. 이는 STI 구조가 가진 '부모 테이블 비대화' 문제를 원천적으로 방지합니다.
- **독립적인 대화방:** 대화가 시작될 때, 원본 `Echo`의 오디오 파일을 **복사**하여 대화방의 첫 `Message`로 만듭니다. 이로써 `ChatRoom`은 시작점이었던 `Echo`가 피드에서 사라지더라도 아무런 영향을 받지 않는, 완전히 독립적인 공간이 됩니다. 이는 '우리 둘만의 비공개 대화'라는 경험을 시스템적으로 보장합니다.

## 2. 데이터 모델 구조

### `echos` 테이블
- `id`: Primary Key
- `user_id`: 메아리를 남긴 사용자 (FK)
- `created_at`, `updated_at`

### `chat_rooms` 테이블
- `id`: Primary Key
- `originating_echo_id`: 어떤 `Echo`로부터 시작되었는지 추적 (FK to `echos`)
- `last_message_at`: 마지막 메시지 시간 (비활성 처리용)
- `created_at`, `updated_at`

### `messages` 테이블
- `id`: Primary Key
- `user_id`: 메시지를 보낸 사용자 (FK)
- `chat_room_id`: 메시지가 속한 대화방 (FK)
- `created_at`, `updated_at`

### `recordings` 테이블
- `id`: Primary Key
- `user_id`: 오디오를 녹음한 원본 사용자 (FK)
- `audio_file_data`: 오디오 파일 (Active Storage)
- `owner_type`: (String, "Echo", "Message")
- `owner_id`: (Integer, `echos.id` or `messages.id`)
- `created_at`, `updated_at`

### `chat_participants` 테이블
- `id`: Primary Key
- `user_id`: 참여자 (FK)
- `chat_room_id`: 참여한 대화방 (FK)
- `status`: 참여 상태 (Integer, Enum으로 관리. e.g., `active: 0`, `left: 1`)
- `created_at`, `updated_at`

### 모델 관계
- `Echo`: `has_one :recording, as: :owner, dependent: :destroy`, `belongs_to :user`
- `Message`: `has_one :recording, as: :owner, dependent: :destroy`, `belongs_to :user`, `belongs_to :chat_room`
- `Recording`: `belongs_to :owner, polymorphic: true`, `belongs_to :user`
- `ChatRoom`: `has_many :messages`, `has_many :chat_participants`
- `User`: `has_many :echos`, `has_many :messages`, `has_many :chat_participants`

## 3. 핵심 로직 흐름 (Sequence)

### 가. 대화 시작
1.  **트리거:** 사용자 B가 사용자 A의 `Echo`에 답장을 녹음하고 전송.
2.  **프로세스 (단일 DB 트랜잭션):**
    a. `ChatRoom` 생성 (`originating_echo_id` 설정).
    b. 사용자 A, B에 대한 `ChatParticipant` 생성 (`status: 'active'`).
    c. **(첫 메시지 복사)** 사용자 A를 `user`로, 원본 `Echo`의 `recording.audio_file` 데이터를 복사하여 새로운 `Recording` 생성.
    d. 방금 생성한 `Recording`을 소유하는 첫번째 `Message` 생성. 이 메시지는 A가 보낸 것으로, `ChatRoom`에 속함.
    e. **(두번째 메시지 생성)** 사용자 B를 `user`로, 답장으로 녹음한 오디오 파일로 새로운 `Recording` 생성.
    f. 이 `Recording`을 소유하는 두번째 `Message` 생성.
    g. `ChatRoom`의 `last_message_at`을 두번째 메시지의 생성 시간으로 업데이트.
3.  **결과:** A와 B에게 새로운 대화방이 보이며, 대화 내역에는 원본 `Echo`의 내용과 B의 첫 답장이 순서대로 표시됨.

### 나. 대화 진행 (턴제)
- 메시지 전송 시, `ChatRoom`의 마지막 `Message`의 `user_id`를 확인. 현재 요청자와 동일하면 전송을 막고, 다를 경우에만 허용.

### 다. 대화 종료
- **3일 비활성:** 백그라운드 잡이 `chat_rooms`의 `last_message_at`을 기준으로 3일 이상 지난 대화를 주기적으로 정리.
- **방 나가기:** `ChatParticipant`의 `status`를 `left`로 변경. 상대방에게는 시스템 알림.

## 4. 신고 및 차단
- 별도 문서에서 정의될 STI + Polymorphic 모델을 통해 처리. 차단 시 관련 `ChatParticipant` 상태를 비활성화하여 모든 상호작용을 즉시 중단.
